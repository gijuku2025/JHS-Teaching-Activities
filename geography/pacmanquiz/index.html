
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pac-Quiz: Knowledge Maze</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
        
		
		
		
        body {
            background-color: #000;
            color: #fff;
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
			touch-action: none; /* âœ… iPad fix */
			
			 }

        .game-container {
            position: relative;
            width: 600px;
            height: 750px;
            border: 4px solid #2424ff;
            border-radius: 8px;
            background: #000;
            box-shadow: 0 0 20px #2424ff;
        }

        #maze-container {
            position: relative;
            width: 100%;
            height: 500px;
            background: #000;
			touch-action: none;
        }

        .wall {
            position: absolute;
            background: #2424ff;
            border: 1px solid #000;
        }

        .dot {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #ffb8ae;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        #pacman {
            position: absolute;
            width: 30px;
            height: 30px;
            background: #ffff00;
            border-radius: 50%;
            z-index: 10;
            transition: transform 0.1s linear;
        }

        /* Pacman Mouth Animation */
        #pacman::after {
            content: '';
            position: absolute;
            right: 0;
            top: 50%;
            width: 50%;
            height: 50%;
            background: #000;
            transform-origin: left bottom;
            clip-path: polygon(0 100%, 100% 100%, 100% 0);
            animation: eat 0.3s infinite alternate;
        }

        @keyframes eat {
            from { transform: rotate(0deg); }
            to { transform: rotate(-45deg); }
        }

        .ghost {
            position: absolute;
            width: 30px;
            height: 30px;
            z-index: 10;
            transition: all 0.1s linear;
            font-size: 24px;
            display: flex;
            justify-content: center;
            align-items: center;
            filter: drop-shadow(0 0 5px rgba(255,255,255,0.5));
        }

        .answer-node {
            position: absolute;
            padding: 4px 8px;
            background: #000;
            border: 2px solid #fff;
            color: #fff;
            font-size: 10px;
            border-radius: 4px;
            z-index: 5;
            transform: translate(-50%, -50%);
            white-space: nowrap;
        }

        .answer-node.correct { border-color: #00ff00; color: #00ff00; }
        .answer-node.wrong { border-color: #ff0000; color: #ff0000; }

        .hud {
            padding: 20px;
            border-top: 4px solid #2424ff;
            height: 250px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        #question-text {
            font-size: 12px;
            line-height: 1.6;
            color: #fff;
            text-align: center;
            margin-bottom: 10px;
        }

        .controls-hint {
            font-size: 8px;
            color: #555;
            text-align: center;
        }

        #score-board {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            color: #ffff00;
        }

        .flash-red { animation: flashRed 0.5s; }
        @keyframes flashRed {
            0%, 100% { background: #000; }
            50% { background: #4a0000; }
        }

		
		.touch-btn {
  background: #2424ff;
  color: white;
  border: none;
  padding: 12px 16px;
  font-size: 18px;
  border-radius: 8px;
}
.touch-btn:active {
  background: #5555ff;
}
		
		
		
		
		
        .flash-green { animation: flashGreen 0.5s; }
        @keyframes flashGreen {
            0%, 100% { background: #000; }
            50% { background: #004a00; }
        }
    </style>
</head>
<body>

    <div class="game-container" id="game-viewport">
        <div id="maze-container">
            <!-- Walls, Dots, and Answers will be injected here -->
            <div id="pacman"></div>
        </div>

        <div class="hud">
            <div id="score-board">
                <span>SCORE: <span id="score">0</span></span>
                <span>LEVEL: <span id="level">1</span></span>
            </div>
            
            <div id="question-area">
                <p id="question-text">Use arrow keys to eat the correct answer!</p>
            </div>

            
			
			
			<div class="controls-hint">
    SWIPE TO MOVE
</div>
        </div>
    </div>

    <!-- Screen Overlays -->
    <div id="overlay" class="fixed inset-0 bg-black/90 flex flex-col items-center justify-center z-50">
        <h1 id="overlay-title" class="text-3xl text-yellow-400 mb-8">PAC-QUIZ</h1>
        <p id="overlay-msg" class="text-sm mb-12 text-center px-10">Eat the correct pellets to survive the maze of knowledge.</p>
        <button id="start-btn" class="bg-blue-600 text-white px-8 py-4 rounded hover:bg-blue-500">START GAME</button>
    </div>

    <script>
        const GRID_SIZE = 40;
        const MAZE_WIDTH = 600;
        const MAZE_HEIGHT = 500;

        const questData = [
            { q: "What is 2 + 2?", a: ["3", "4", "5", "22"], correct: "4" },
            { q: "Which planet is 'Red'?", a: ["Earth", "Mars", "Venus", "Jupiter"], correct: "Mars" },
            { q: "Water chemical formula?", a: ["CO2", "H2O", "O2", "NaCl"], correct: "H2O" },
            { q: "First man on moon?", a: ["Armstrong", "Aldrin", "Gagarin", "Musk"], correct: "Armstrong" },
            { q: "Smallest unit of life?", a: ["Atom", "Cell", "Organ", "Virus"], correct: "Cell" }
        ];

        let state = {
            pacman: { x: 40, y: 40, dir: 'right' },
            ghosts: [
                { x: 520, y: 40, vx: 0, vy: 0, emoji: 'ðŸ‘»' },
                { x: 520, y: 400, vx: 0, vy: 0, emoji: 'ðŸ’€' },
                { x: 40, y: 400, vx: 0, vy: 0, emoji: 'ðŸ‘¾' }
            ],
            score: 0,
            level: 1,
            gameActive: false,
            currentQuestion: 0
        };

        const mazeLayout = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,0,0,0,0,1,0,0,0,1,0,0,0,0,1],
            [1,0,1,1,0,1,0,1,0,1,0,1,1,0,1],
            [1,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,1,1,1,1,0,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,0,1,1,0,1,0,1,0,1,0,1,1,0,1],
            [1,0,1,1,0,1,0,1,0,1,0,1,1,0,1],
            [1,0,0,0,0,0,0,1,0,0,0,0,0,0,1],
            [1,0,1,1,1,1,0,1,0,1,1,1,1,0,1],
            [1,0,0,0,0,0,0,0,0,0,0,0,0,0,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
        ];

        const mazeContainer = document.getElementById('maze-container');
		let touchStartX = 0;
let touchStartY = 0;

mazeContainer.addEventListener("touchstart", (e) => {
  const t = e.touches[0];
  touchStartX = t.clientX;
  touchStartY = t.clientY;
}, { passive: false });

mazeContainer.addEventListener("touchend", (e) => {
  const t = e.changedTouches[0];
  const dx = t.clientX - touchStartX;
  const dy = t.clientY - touchStartY;

  const minSwipe = 30; // ignore tiny movements

  if (Math.abs(dx) > Math.abs(dy)) {
    if (Math.abs(dx) > minSwipe) {
      state.pacman.dir = dx > 0 ? "right" : "left";
    }
  } else {
    if (Math.abs(dy) > minSwipe) {
      state.pacman.dir = dy > 0 ? "down" : "up";
    }
  }
});
		
		
		
		
        const pacmanEl = document.getElementById('pacman');

        function createMaze() {
            mazeContainer.innerHTML = '<div id="pacman"></div>';
            mazeLayout.forEach((row, rIdx) => {
                row.forEach((cell, cIdx) => {
                    if (cell === 1) {
                        const wall = document.createElement('div');
                        wall.className = 'wall';
                        wall.style.width = GRID_SIZE + 'px';
                        wall.style.height = GRID_SIZE + 'px';
                        wall.style.left = (cIdx * GRID_SIZE) + 'px';
                        wall.style.top = (rIdx * GRID_SIZE) + 'px';
                        mazeContainer.appendChild(wall);
                    } else if (Math.random() > 0.85) {
                        const dot = document.createElement('div');
                        dot.className = 'dot';
                        dot.style.left = (cIdx * GRID_SIZE + GRID_SIZE/2) + 'px';
                        dot.style.top = (rIdx * GRID_SIZE + GRID_SIZE/2) + 'px';
                        mazeContainer.appendChild(dot);
                    }
                });
            });
        }

        function spawnAnswers() {
            document.querySelectorAll('.answer-node').forEach(n => n.remove());
            const question = questData[state.currentQuestion];
            document.getElementById('question-text').innerText = question.q;

            const spawnPoints = [
                {x: 140, y: 140}, {x: 460, y: 140},
                {x: 140, y: 380}, {x: 460, y: 380}
            ];

            question.a.forEach((ans, i) => {
                const node = document.createElement('div');
                node.className = 'answer-node';
                node.innerText = ans;
                node.dataset.value = ans;
                node.style.left = spawnPoints[i].x + 'px';
                node.style.top = spawnPoints[i].y + 'px';
                mazeContainer.appendChild(node);
            });
        }

        function update() {
            if (!state.gameActive) return;

            // Move Pacman
            let nextX = state.pacman.x;
            let nextY = state.pacman.y;
            const speed = 4;

            if (state.pacman.dir === 'up') nextY -= speed;
            if (state.pacman.dir === 'down') nextY += speed;
            if (state.pacman.dir === 'left') nextX -= speed;
            if (state.pacman.dir === 'right') nextX += speed;

            if (!isWall(nextX, nextY)) {
                state.pacman.x = nextX;
                state.pacman.y = nextY;
            }

            const pacmanEl = document.getElementById('pacman');
            pacmanEl.style.left = state.pacman.x + 'px';
            pacmanEl.style.top = state.pacman.y + 'px';

            const rotations = { 'right': 0, 'down': 90, 'left': 180, 'up': 270 };
            pacmanEl.style.transform = `rotate(${rotations[state.pacman.dir]}deg)`;

            checkAnswerCollision();
            moveGhosts();

            requestAnimationFrame(update);
        }

        function isWall(x, y) {
            const size = 26; // slightly smaller than 30 for easier turning
            const points = [
                {x: x + 4, y: y + 4},
                {x: x + size, y: y + 4},
                {x: x + 4, y: y + size},
                {x: x + size, y: y + size}
            ];

            return points.some(p => {
                const col = Math.floor(p.x / GRID_SIZE);
                const row = Math.floor(p.y / GRID_SIZE);
                return mazeLayout[row] && mazeLayout[row][col] === 1;
            });
        }

        function checkAnswerCollision() {
            const nodes = document.querySelectorAll('.answer-node');
            const pRect = document.getElementById('pacman').getBoundingClientRect();

            nodes.forEach(node => {
                const nRect = node.getBoundingClientRect();
                if (!(pRect.right < nRect.left || pRect.left > nRect.right || pRect.bottom < nRect.top || pRect.top > nRect.bottom)) {
                    const val = node.dataset.value;
                    const correctVal = questData[state.currentQuestion].correct;

                    if (val === correctVal) {
                        state.score += 100;
                        mazeContainer.classList.add('flash-green');
                        setTimeout(() => mazeContainer.classList.remove('flash-green'), 500);
                        state.currentQuestion++;
                        if (state.currentQuestion >= questData.length) {
                            endGame(true);
                        } else {
                            spawnAnswers();
                        }
                    } else {
                        state.score = Math.max(0, state.score - 50);
                        mazeContainer.classList.add('flash-red');
                        setTimeout(() => mazeContainer.classList.remove('flash-red'), 500);
                        node.remove();
                    }
                    document.getElementById('score').innerText = state.score;
                }
            });
        }

		
		
		
		
		
		
		
		
        function moveGhosts() {
            const pX = state.pacman.x;
            const pY = state.pacman.y;
            const ghostSpeed = 2;

            state.ghosts.forEach((ghost, i) => {
                let el = document.getElementById(`ghost-${i}`);
                if (!el) el = createGhostEl(i, ghost);
                
                // Better AI logic: Change direction if hitting a wall or randomly
                if (Math.random() > 0.96 || isWall(ghost.x + ghost.vx, ghost.y + ghost.vy)) {
                    const diffX = pX - ghost.x;
                    const diffY = pY - ghost.y;
                    
                    // Choose direction towards pacman or random
                    if (Math.abs(diffX) > Math.abs(diffY)) {
                        ghost.vx = diffX > 0 ? ghostSpeed : -ghostSpeed;
                        ghost.vy = 0;
                    } else {
                        ghost.vy = diffY > 0 ? ghostSpeed : -ghostSpeed;
                        ghost.vx = 0;
                    }
                }

                // Apply movement if possible
                if (!isWall(ghost.x + ghost.vx, ghost.y + ghost.vy)) {
                    ghost.x += ghost.vx;
                    ghost.y += ghost.vy;
                } else {
                    // Stop if hitting wall to force logic recalc next frame
                    ghost.vx = 0;
                    ghost.vy = 0;
                }

                el.style.left = ghost.x + 'px';
                el.style.top = ghost.y + 'px';

                // Hit detection
                const pRect = document.getElementById('pacman').getBoundingClientRect();
                const gRect = el.getBoundingClientRect();
                if (!(pRect.right < gRect.left || pRect.left > gRect.right || pRect.bottom < gRect.top || pRect.top > gRect.bottom)) {
                    endGame(false);
                }
            });
        }

        function createGhostEl(id, ghost) {
            const el = document.createElement('div');
            el.id = `ghost-${id}`;
            el.className = 'ghost';
            el.innerText = ghost.emoji;
            mazeContainer.appendChild(el);
            return el;
        }

        function endGame(win) {
            state.gameActive = false;
            const overlay = document.getElementById('overlay');
            const title = document.getElementById('overlay-title');
            const msg = document.getElementById('overlay-msg');
            
            overlay.classList.remove('hidden');
            title.innerText = win ? "GAME CLEAR!" : "GAME OVER";
            title.style.color = win ? "#00ff00" : "#ff0000";
            msg.innerText = win ? `Knowledge is power! Score: ${state.score}` : "The ghosts of ignorance caught you.";
            document.getElementById('start-btn').innerText = "TRY AGAIN";
        }

       
        document.getElementById('start-btn').onclick = startGame;

        function startGame() {
            document.getElementById('overlay').classList.add('hidden');
            createMaze();
            state.gameActive = true;
            state.currentQuestion = 0;
            state.score = 0;
            state.pacman = { x: 40, y: 40, dir: 'right' };
            
            // Fixed Ghost spawn positions in clear areas
            state.ghosts[0].x = 520; state.ghosts[0].y = 40;
            state.ghosts[1].x = 520; state.ghosts[1].y = 400;
            state.ghosts[2].x = 40; state.ghosts[2].y = 400;
            
            state.ghosts.forEach(g => { g.vx = 0; g.vy = 0; });
            
            document.getElementById('score').innerText = '0';
            spawnAnswers();
            update();
        }

        createMaze();
    </script>
</body>
</html>
